این فصل دوم، دقیقاً در راستای ساختار کتاب، فلسفه‌ی ضدشکنندگی را به اولین ستون عملی CAP یعنی "Architecture Governance as Code" پیوند می‌دهد.

---

# **فصل دوم – Governance-as-Code: معماری خودنظار**

> **شکنندگی ناشی از سکوت است. سیستم‌های ضدشکننده، بلند فکر می‌کنند.**

## ۲.۱ پارادوکس بزرگ معمار: مرزهای شکسته

اگر معمار بودید و بنایی می‌ساختید، می‌توانستید مطمئن باشید ستونی که امروز در طبقه همکف قرار دادید، فردا به طور جادویی به طبقه پنجم منتقل نمی‌شود. اما در دنیای نرم‌افزار، این جادو روزانه اتفاق می‌افتد.

معماران Clean Architecture، بهترین قوانین را طراحی می‌کنند: لایه‌ی **Domain** نباید به **Infrastructure** وابسته باشد. **Application Core** نباید چیزهایی را ببیند که نباید ببیند. این قوانین زیبا هستند، اما مشکل اینجاست:

**آن‌ها صامت (Silent) هستند.**

این سکوت است که باعث **فرسایش معماری (Architectural Erosion)** می‌شود.
یک توسعه‌دهنده در فشار انتشار، یک `using` اشتباهی اضافه می‌کند. چون کامپایلر اعتراضی نمی‌کند و تست‌های واحد هنوز سبز هستند، این تخطی کوچک نادیده گرفته می‌شود. هفته‌ها بعد، ده‌ها تخطی کوچک دیگر رخ می‌دهد و ناگهان، معماری دیگر تمیز نیست. ما به‌جای یک ساختار منظم، با یک توده‌ی به هم چسبیده مواجه‌ایم.

معماری تمیز در نهایت می‌شکند، چون صرفاً یک **توصیه** است، نه یک **قانون فعال** در سیستم.

## ۲.۲ نیاز به سیستم ایمنی معماری

اگر Clean Architecture را به بدن انسان تشبیه کنیم، قوانین و مرزهای آن، اسکلت بدن هستند. اما سیستم ایمنی کجاست؟

در گذشته، حفظ معماری عمدتاً بر عهده‌ی بازبینی‌های دستی کد (Code Reviews) بود. این روش آهسته، خطاپذیر و شکننده است. یک معمار ممکن است خسته شود، یا در یک تغییر بزرگ، مرزها را نبیند.

**CAP این مفهوم را تغییر می‌دهد:**

> حفاظت از معماری باید نه در مغز معمار، بلکه در DNA خود سیستم کدگذاری شود.

هدف ما ساختن یک **سیستم ایمنی معماری (Architectural Immune System)** است که:
1.  قوانین را به زبان کد بنویسد.
2.  با هر کامیت، آن قوانین را اجرا کند.
3.  با هر نقض قانون، سیستم را از انتشار بازدارد (شکستن Build).

اینجاست که مفهوم **Governance-as-Code** مطرح می‌شود. قوانین (Governance) دیگر مستندات Passive نیستند، بلکه کدی فعال (Code) هستند که باید مانند هر تست دیگری پاس شوند.

## ۲.۳ Governance-as-Code: ستون اول ضدشکنندگی

Governance-as-Code یعنی استفاده از ابزارهای تحلیل کد ایستا (Static Analysis) و تست‌های سطح معماری برای تعریف، پایش و اجرای خودکار قوانین طراحی.

این روش دقیقاً ضدشکننده است، زیرا شکست‌های کوچک را کنترل‌شده به چرخه‌ی توسعه وارد می‌کند تا از شکست‌های فاجعه‌بار در Production جلوگیری شود.

### ۲.۳.۱ معماری‌اش را بنویس، نه فقط بکش!

در این مدل، ما یک پروژه‌ی تست جداگانه تعریف می‌کنیم که *تنها وظیفه‌اش* تست کردن خود ساختار معماری است.

برای مثال، یک توسعه‌دهنده‌ی C# می‌تواند از کتابخانه‌ای مانند **NetArchTest** استفاده کند (یا ArchUnit در اکوسیستم جاوا) تا قوانین کلیدی را به صراحت بیان کند:

```csharp
// قوانین معماری CAP در کد:
// قانون ۱: لایه Application نباید مستقیماً به Infrastructure وابسته باشد
Types.InAssembly(ApplicationAssembly)
     .ShouldNot()
     .HaveDependencyOn(InfrastructureAssembly)
     .Check("Application Core must not reference Infrastructure");

// قانون ۲: همه کلاس‌های Command باید در پوشه Commands باشند
Types.InAssembly(ApplicationAssembly)
     .That()
     .HaveNameEndingWith("Command")
     .Should()
     .ResideInNamespace("MyProject.Application.Commands")
     .Check();
```

وقتی این تست معماری در خط لوله CI شکست می‌خورد، دیگر بحث و جدلی بر سر معماری وجود ندارد. *کد دروغ نمی‌گوید.* این سیستم ایمنی فعال، مانع فرسایش آهسته می‌شود.

### ۲.۳.۲ نقش ابزارهای تحلیل ایستا (Analyzers)

تست‌های معماری (Architecture Tests) برای پایش مرزهای بزرگ ماژولی عالی هستند، اما برای تخطی‌های ریزتر، به **Analyzer**ها (مانند Roslyn Analyzers در دات‌نت) نیاز داریم.

Analyzerها قوانین را به داخل IDE می‌آورند. اگر توسعه‌دهنده متغیری را در جای اشتباه تعریف کند، Analyzer زیر آن خط می‌کشد و در همان لحظه هشدار می‌دهد.

> **این یک تغییر فرهنگی است:** معمار دیگر یک پلیس در پایان پروژه نیست، بلکه یک هوش مصنوعی فعال است که در لحظه، توسعه‌دهنده را راهنمایی می‌کند و از او می‌آموزد.

## ۲.۴ ضدشکنندگی عملیاتی Governance-as-Code

چگونه این مکانیسم باعث **قوی‌تر شدن** سیستم می‌شود؟

در سیستم‌های سنتی، شکنندگی پنهان است و فقط در اثر یک Load Spike یا یک تغییر بزرگ ظاهر می‌شود. در CAP:

1.  **شکست زودرس (Early Failure):** ما به‌جای پذیرش خطا در Production، آن را در **Build Pipeline** تجربه می‌کنیم. این شکست کنترل‌شده (شکستن Build) یک سیگنال قوی برای یادگیری است.
2.  **داده‌های یادگیری:** هر بار که یک قانون نقض می‌شود، تیم اطلاعات دقیقی در مورد نقطه ضعف فعلی خود به دست می‌آورد. آیا قوانینمان خیلی سختگیرانه بوده‌اند؟ آیا ساختار پوشه‌ها باید تغییر کند؟
3.  **اصلاح خودکار (Self-Correction):** سیستم (Pipeline) خود را با اجبار به اصلاح ساختار کد (Refactor) تطبیق می‌دهد، و معماری با هر تکرار، منسجم‌تر می‌شود.

> معماری ضدشکننده، معماری‌ای نیست که شکست نمی‌خورد؛ بلکه معماری‌ای است که هر بار شکست می‌خورد، مرزهای خود را بهتر می‌شناسد و مکانیسم دفاعی‌اش را قوی‌تر می‌کند.

## ۲.۵ تکامل معماری: از MVC تا CAP

تحلیل تاریخی نشان می‌دهد که هر جهش بزرگ در معماری نرم‌افزار، تلاشی بوده برای افزایش *خودآگاهی* سیستم:

| معماری | دغدغه اصلی | کنترل مرزها | شکنندگی باقی‌مانده |
| :--- | :--- | :--- | :--- |
| **MVC** | جداسازی نمایش از منطق | دستی (با قراردادهای نامگذاری) | وابستگی‌های آشکار به فریم‌ورک |
| **Clean Architecture** | استقلال دامنه از زیرساخت | قوانین تزریق وابستگی (DI) | قوانین صامت (عدم پایش خودکار) |
| **CAP** | معماری ضدشکننده | **Governance-as-Code** | شکنندگی در ارتباطات (Contracts) و SLO |

CAP با حل مشکل "قوانین صامت" از طریق Governance-as-Code، اولین گام را به سمت یک ارگانیسم دیجیتال برداشت.

## ۲.۶ مسیر پیش رو

Governance-as-Code ابزار ماست برای اطمینان از **نظم درونی** ماژول‌ها. اما یک سیستم تنها به دلیل نظم داخلی‌اش ضدشکننده نیست.

در فصل بعد، به **ستون دوم CAP** خواهیم پرداخت: **قراردادهای نسخه‌دار و تست‌پذیر**. چگونه سیستمی که از درون تمیز است، می‌تواند در ارتباط با جهان خارجی (سرویس‌های دیگر) انعطاف‌پذیر بماند و از نوسان داده‌ها و تغییر APIها قوی‌تر شود؟

---
**پایان فصل دوم**
